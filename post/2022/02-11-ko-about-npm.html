<!DOCTYPE html>
<html lang="ko">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="../../favicon.ico" />
		<meta name="viewport" content="width=device-width" />
		
		<link href="../../_app/immutable/assets/0.5d50d51a.css" rel="stylesheet">
		<link rel="modulepreload" href="../../_app/immutable/entry/start.d2d44a37.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/scheduler.6402f0dd.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/singletons.99c33a7c.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/index.1b92e39a.js">
		<link rel="modulepreload" href="../../_app/immutable/entry/app.8cd8adc2.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/index.0cc09f3a.js">
		<link rel="modulepreload" href="../../_app/immutable/nodes/0.498ba3f8.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/index.a82faf3f.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/GithubMark.5170f17a.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/store.be990f37.js">
		<link rel="modulepreload" href="../../_app/immutable/nodes/5.27291db7.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/each.e59479a4.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/Category.28578094.js">
		<link rel="modulepreload" href="../../_app/immutable/chunks/MainSection.49f196b2.js"><title>npm에 대하여 : dlguswo333&#39;s blog</title><!-- HEAD_svelte-etxm8u_START --><!-- HEAD_svelte-etxm8u_END -->
		<!-- [TODO] For portability I can erase the following elements and inject them from index.ts when building? -->
		<title>dlguswo333's Blog</title>
		<meta name="google-site-verification" content="GIhlBkE7qu5AWLVmQ4w2lBcxEw-AumQhdQf_2zR2X4s" />
	</head>
	<body data-sveltekit-preload-data="hover">
		<script>
			const systemTheme= window.matchMedia('(prefers-color-scheme:dark)').matches ? 'dark' : 'light';
			const rootElement = document.querySelector('body');
			try {
				const storedValue = JSON.parse(localStorage.getItem('color-theme') || 'null');
				const currentTheme = storedValue === 'light' || storedValue === 'dark' ? storedValue : systemTheme;
				if(rootElement) {
  				rootElement.classList.add(currentTheme);
				}
			} catch {
				rootElement.classList.add(systemTheme);
			}
		</script>
		<div id="root">  <header class="p-2 sticky top-0 flex flex-row items-center justify-between border-b border-b-gray-300 bg-gray-50 dark:bg-[#2c3039] dark:border-b-gray-700"><div class="flex flex-row items-center gap-1"> <a href="/" class="inline-block h-8 w-8" data-svelte-h="svelte-htzscq"><span class="hidden">Go To Home</span> <img src="/favicon.svg" alt="Logo"></a> <button type="button" title="Toggle color theme" class="group"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" class="h-8 w-8 transition"><rect x="3" y="3" width="94" height="94" stroke-width="6" rx="16" ry="16" class="stroke-gray-600 fill-none"></rect></svg></button> </div> <div class="flex flex-row items-center"><a href="/categories" class="h-8 flex items-center justify-center mr-2 last:mr-1 px-1 py-0.5 rounded hover:bg-gray-200 dark:hover:bg-slate-600 dark:hover:text-white">Categories</a> <a href="/tags" class="h-8 flex items-center justify-center mr-2 last:mr-1 px-1 py-0.5 rounded hover:bg-gray-200 dark:hover:bg-slate-600 dark:hover:text-white">Tags</a> <a href="/about" class="h-8 flex items-center justify-center mr-2 last:mr-1 px-1 py-0.5 rounded hover:bg-gray-200 dark:hover:bg-slate-600 dark:hover:text-white">About</a></div></header>  <div class="flex flex-row flex-grow justify-center p-2 lg:p-0 lg:pr-[300px]"> <aside class="w-[300px] overflow-hidden hidden mt-10 self-start md:!flex md:sticky md:top-14 flex-col justify-center items-center p-3
  "><div class="relative w-full"><ul class="max-h-[80vh] overflow-auto"> <li title="1. 의존성 관리" class="flex border-l-4 border-transparent hover:border-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 font-bold 
        "><a href="#1-1.-의존성-관리" class="relative z-10 py-0.5 whitespace-nowrap overflow-hidden break-all overflow-ellipsis flex-grow" style="padding-left: 0.3rem;">1. 의존성 관리</a> </li> <li title="버전 명세" class="flex border-l-4 border-transparent hover:border-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700  
        "><a href="#2-버전-명세" class="relative z-10 py-0.5 whitespace-nowrap overflow-hidden break-all overflow-ellipsis flex-grow" style="padding-left: 0.9666666666666666rem;">버전 명세</a> </li> <li title="dependencies vs. devDependencies" class="flex border-l-4 border-transparent hover:border-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700  
        "><a href="#3-dependencies-vs.-devDependencies" class="relative z-10 py-0.5 whitespace-nowrap overflow-hidden break-all overflow-ellipsis flex-grow" style="padding-left: 0.9666666666666666rem;">dependencies vs. devDependencies</a> </li> <li title="peerDependencies" class="flex border-l-4 border-transparent hover:border-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700  
        "><a href="#4-peerDependencies" class="relative z-10 py-0.5 whitespace-nowrap overflow-hidden break-all overflow-ellipsis flex-grow" style="padding-left: 0.9666666666666666rem;">peerDependencies</a> </li> <li title="package-lock.json" class="flex border-l-4 border-transparent hover:border-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700  
        "><a href="#5-package-lock.json" class="relative z-10 py-0.5 whitespace-nowrap overflow-hidden break-all overflow-ellipsis flex-grow" style="padding-left: 0.9666666666666666rem;">package-lock.json</a> </li> <li title="2. npm Command" class="flex border-l-4 border-transparent hover:border-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 font-bold 
        "><a href="#6-2.-npm-Command" class="relative z-10 py-0.5 whitespace-nowrap overflow-hidden break-all overflow-ellipsis flex-grow" style="padding-left: 0.3rem;">2. npm Command</a> </li> <li title="npm audit" class="flex border-l-4 border-transparent hover:border-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700  
        "><a href="#7-npm-audit" class="relative z-10 py-0.5 whitespace-nowrap overflow-hidden break-all overflow-ellipsis flex-grow" style="padding-left: 0.9666666666666666rem;">npm audit</a> </li> <li title="npm ci" class="flex border-l-4 border-transparent hover:border-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700  
        "><a href="#8-npm-ci" class="relative z-10 py-0.5 whitespace-nowrap overflow-hidden break-all overflow-ellipsis flex-grow" style="padding-left: 0.9666666666666666rem;">npm ci</a> </li> <li title="npm completion" class="flex border-l-4 border-transparent hover:border-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700  
        "><a href="#9-npm-completion" class="relative z-10 py-0.5 whitespace-nowrap overflow-hidden break-all overflow-ellipsis flex-grow" style="padding-left: 0.9666666666666666rem;">npm completion</a> </li> <li title="npm ls" class="flex border-l-4 border-transparent hover:border-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700  
        "><a href="#10-npm-ls" class="relative z-10 py-0.5 whitespace-nowrap overflow-hidden break-all overflow-ellipsis flex-grow" style="padding-left: 0.9666666666666666rem;">npm ls</a> </li> <li title="npm outdated" class="flex border-l-4 border-transparent hover:border-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700  
        "><a href="#11-npm-outdated" class="relative z-10 py-0.5 whitespace-nowrap overflow-hidden break-all overflow-ellipsis flex-grow" style="padding-left: 0.9666666666666666rem;">npm outdated</a> </li> <li title="npm uninstall" class="flex border-l-4 border-transparent hover:border-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700  
        "><a href="#12-npm-uninstall" class="relative z-10 py-0.5 whitespace-nowrap overflow-hidden break-all overflow-ellipsis flex-grow" style="padding-left: 0.9666666666666666rem;">npm uninstall</a> </li> <li title="npm update" class="flex border-l-4 border-transparent hover:border-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700  
        "><a href="#13-npm-update" class="relative z-10 py-0.5 whitespace-nowrap overflow-hidden break-all overflow-ellipsis flex-grow" style="padding-left: 0.9666666666666666rem;">npm update</a> </li> <li title="npm pack" class="flex border-l-4 border-transparent hover:border-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700  
        "><a href="#14-npm-pack" class="relative z-10 py-0.5 whitespace-nowrap overflow-hidden break-all overflow-ellipsis flex-grow" style="padding-left: 0.9666666666666666rem;">npm pack</a> </li> <li title="3. NodeJS에서 import 쓰기" class="flex border-l-4 border-transparent hover:border-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 font-bold 
        "><a href="#15-3.-NodeJS에서-import-쓰기" class="relative z-10 py-0.5 whitespace-nowrap overflow-hidden break-all overflow-ellipsis flex-grow" style="padding-left: 0.3rem;">3. NodeJS에서 import 쓰기</a> </li> <li title="4. npm vs. yarn" class="flex border-l-4 border-transparent hover:border-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 font-bold 
        "><a href="#16-4.-npm-vs.-yarn" class="relative z-10 py-0.5 whitespace-nowrap overflow-hidden break-all overflow-ellipsis flex-grow" style="padding-left: 0.3rem;">4. npm vs. yarn</a> </li> <li title="5. 참조" class="flex border-l-4 border-transparent hover:border-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 font-bold 
        "><a href="#17-5.-참조" class="relative z-10 py-0.5 whitespace-nowrap overflow-hidden break-all overflow-ellipsis flex-grow" style="padding-left: 0.3rem;">5. 참조</a> </li></ul> </div></aside>  <div class="flex flex-col justify-center min-w-0"><div class="max-w-[900px] flex flex-col items-center py-6 gap-3"><h1 class="text-4xl font-bold text-center">npm에 대하여</h1> <span>2022-02-11 (Edited 2022-12-19)</span> <button class="px-2 py-0.5 rounded-lg shadow-md shadow-emerald-50 border-l-slate-100 bg-sky-300 text-white hover:bg-sky-500 dark:shadow-emerald-900 transition">/Programming</button> <div><button class="last:mr-0 bg-green-100 hover:bg-green-400 hover:text-white dark:text-black transition px-2 py-0.5 rounded-xl shadow-md dark:shadow-green-900" style="margin-right: 0.25rem; margin-left: 0.5rem">#npm</button><button class="last:mr-0 bg-green-100 hover:bg-green-400 hover:text-white dark:text-black transition px-2 py-0.5 rounded-xl shadow-md dark:shadow-green-900" style="margin-right: 0.25rem; margin-left: 0rem">#javascript</button></div></div> <hr class="bg-gray-400 my-4">  <main class="max-w-[900px] w-full py-2 post"> <!-- HTML_TAG_START --><p align="center">
  <img src="/img/2022-02-11-about-npm/npm-logo.svg">
</p>
<p>Node Package Manager, npm은 NodeJS 패키지 매니저로서 패키지 설치, 의존성 관리의 역할을 수행합니다.</p>
<!--more-->
<p>JS 개발자로서 매일 같이 유용하게 쓰고 있음에도 불구하고 npm에 대해 마음을 다잡고 공부해 본 적이 없어서
이 포스트를 쓰게 되었습니다. npm에서 자주 쓰이지만 따로 공부하지 않으면 제대로 알기 힘든 기능을
중심으로 훑어가도록 하겠습니다.</p>
<h1 id="1-1.-의존성-관리">1. 의존성 관리</h1>
<p>npm에서는 패키지의 이름, 작성자, 설명과 의존성 관리 등을 <code>package.json</code>을 통해 관리하고 있습니다.
<code>npm init</code>을 하면 프로젝트 루트 폴더에 생기는 바로 그 파일인데, 여기에 패키지에 대한 정보를 json 형태로
저장하게 됩니다. <code>package.json</code>은 사람 뿐만 아니라 npm에서도 패키지 정보를 얻기 위해 활용하기 때문에
지우면 안됩니다.</p>
<blockquote>
<p>참고로 <code>npm ls</code>를 실행하면 의존성 패키지 목록을 훑어볼 수 있습니다. 여기에 <code>--depth &#x3C;Number></code> 파라미터를
넘겨주면 의존 패키지가 또 의존하는 패키지를 해당 깊이만큼 트리 형태로 볼 수 있습니다. 여기에 <code>-g</code> 또는
<code>--global</code> 플래그를 넘겨주면 글로벌 스코프로 설치된 패키지의 의존성 트리를 볼 수 있습니다.</p>
</blockquote>
<h2 id="2-버전-명세">버전 명세</h2>
<p>NodeJS 패키지들은 <code>x.y.z</code>와 같이 세 개의 숫자로 구성된 버전 형식을 사용하는데, 이를
<em>Semantic Versioning</em>이라 합니다. 년-월-일과 같이 세 숫자는 메이저-마이너-패치의 의미를 가지고 있습니다.
왼쪽으로 갈수록 패키지가 많이 다르다는 뜻이죠. 버그 픽스를 반영했으면 <code>z</code>를 바꾸고, 기능이 추가되면서
전 버전과 호환되면 <code>y</code>를, 전 버전과 호환이 안 되거나 그 만큼의 기능이 바뀌었으면 <code>x</code>를 바꿔주는 방법으로
버전을 정하면 됩니다.</p>
<p>물론 이를 반드시 지키지 않아도 되고 실제로 지키지 않아도 npm에 패키지 업로드는 잘 됩니다만, 이를 지켜주는게
좋습니다. npm에서 의존성 관리를 할 때 의존하고 있는 패키지 버전을 위 규칙을 기반으로 관리하기 때문입니다.</p>
<p>패키지를 설치하고 <code>package.json</code>에 들어가면 dependencies 또는 devdependencies에 의존 패키지 이름과
함께 버전이 적혀 있는데 버전만 적혀있는 것이 아니라 <code>^x.y.z</code>, <code>>=x.y.z</code>와 같이 특수문자를 포함해서
적혀있는 것을 보셨을 겁니다. 사용할 수 있는 특수문자와 그 의미는 아래와 같습니다.</p>
<p><strong>^</strong><br>
<code>^x.y.z</code>와 같이 쓰며 가장 왼쪽의 0이 아닌 값을 바꾸지 않는 선에서 그 이상의 버전을 사용 가능.
예를 들어 <code>^1.0.0</code>일 때 <code>1.0.1</code>, <code>1.1.0</code>으로 업데이트는 가능하지만 <code>2.0.0</code>으로는 업데이트 하지 않습니다.
또 <code>^0.3.0</code>이면 <code>0.3.1</code>과 <code>0.3.2</code>는 가능하지만 <code>0.4.0</code>은 불가능합니다.</p>
<p><strong>~</strong><br>
<code>~x.y.z</code>와 같이 쓰며 <code>z</code> 버전만 바꾸는 선에서 그 이상의 버전을 사용 가능. 예를 들어 <code>~1.0.0</code>일 때
<code>1.0.1</code>은 가능하지만 <code>1.1.0</code>은 불가능합니다.</p>
<p><strong>></strong><br>
<code>>x.y.z</code>와 같이 쓰며 <code>x.y.z</code>보다 높은 버전을 명시하기 위해 사용합니다.</p>
<p><strong>>=</strong><br>
<code>>=x.y.z</code>와 같이 쓰며 <code>x.y.z</code> 이상의 버전을 명시하기 위해 사용합니다.</p>
<p><strong>&#x3C;</strong><br>
<code>&#x3C;x.y.z</code>와 같이 쓰며 <code>x.y.z</code>보다 낮은 버전을 명시하기 위해 사용합니다.</p>
<p><strong>&#x3C;=</strong><br>
<code>&#x3C;=x.y.z</code>와 같이 쓰며 <code>x.y.z</code> 이하의 버전을 명시하기 위해 사용합니다.</p>
<p><strong>=</strong><br>
<code>=x.y.z</code>와 같이 쓰며 <code>x.y.z</code> 버전 만을 명시하기 위해 사용합니다. <code>x.y.z</code>와 같은 효과를 가집니다.</p>
<p><strong>-</strong><br>
<code>a.b.c - x.y.z</code>와 같이 쓰며 범위를 지정할 때 사용합니다. 이 때 범위는 양쪽 inclusive 입니다.</p>
<p><strong>||</strong><br>
<code>&#x3C;...> || &#x3C;...></code>와 같이 쓰며 두 명세를 조합할 때 (OR) 쓸 때 사용합니다. 예를 들어 <code>0.1.0 || ^1.0.0</code>은
<code>0.1.0</code> 버전과 <code>1.y.z</code> 버전을 명시할 수 있습니다.</p>
<blockquote>
<p>직접 시험해보고 싶으시다면 원하시는 특정 패키지에 대해 Semantic Versioning을 테스트해볼 수 있는
npm 공식 사이트 (<a href="https://semver.npmjs.com/">링크</a>)가 존재합니다.</p>
</blockquote>
<h2 id="3-dependencies-vs.-devDependencies">dependencies vs. devDependencies</h2>
<p>npm 패키지에서 의존성들은 dependencies와 devDependencies로 관리합니다. 패키지 실행 시 필요한 (런타임)
의존성들은 dependencies로, 그 외 개발에 필요한 패키지들은 devDependencies로 가는 식으로 나눠주죠.</p>
<blockquote>
<p>일일이 <code>package.json</code>에 들어가 분리할 필요 없이
<code>npm i &#x3C;Package Name></code>에 <code>--save</code> (또는 <code>-S</code>) 플래그를 붙이면 dependencies로,
<code>npm i &#x3C;Package Name></code>에 <code>--save-dev</code> (또는 <code>-D</code>) 플래그를 붙이면 devDependencies로 알아서
npm이 분리해줍니다.</p>
</blockquote>
<p>예를 들어 eslint로 코드 컨벤션을 관리하며 express.JS로 백엔드 서버를 제작했다고 합시다.
eslint는 런타임에는 전혀 필요가 없고 서버를 돌릴 때 코드 컨벤션은 맞춰줄 필요가 없으니 devDependencies로,
express.JS는 서버 런타임 동작 시 필요하니 dependencies로 지정하는 것이 적합하겠죠.</p>
<p>그런데 <code>npm install</code> (또는 <code>npm i</code>) 명령어를 통해 의존성 패키지를 설치 시 dependencies 뿐만 아니라
devDependencies도 함께 설치됨을 알 수 있습니다. 어차피 둘 다 한꺼번에 설치되는데 왜 굳이 분리하는 걸까요?</p>
<p>이는 우리가 제작한 패키지가 다른 패키지에 의해 참조될 때를 위한 것입니다. 우리가 git을 통해 패키지를 내려 받고
제작하는 것은 해당 패키지를 직접 뜯어 고치는 작업입니다. 이미 우리가 해당 패키지를 개발한다는 의미를 지니고 있기에
인스톨 명령 시 두 의존성을 다 설치하는 것이죠.</p>
<p>하지만 다른 패키지가 우리 패키지에 의존할 시에는 상황이 다릅니다. 우리 패키지가 필요한 것이지, 직접 뜯어 고치고
싶지는 않을테죠. 다시 위의 express.JS 백엔드 서버를 예를 들어봅시다. 누군가가 우리의 백엔드 서버를 필요로 해서
의존성으로 설치할 시 express.JS는 dependencies에 명시되어 있기에 자동적으로 설치되겠지만 eslint는 설치되지
않을 것입니다. devDependencies에 명시되어 있으니까요.</p>
<h2 id="4-peerDependencies">peerDependencies</h2>
<p>peerDependencies란 <strong>이 패키지가 이러한 의존 패키지들을 직접적으로 사용하지는 않지만 명시한 버전만 사용 가능하다</strong>
라는 것을 표현하고 싶을 때 사용합니다. 즉 다시 말해 런타임 시 필요하지는 않지만 호환되는 버전을 나타내고 싶을 때
사용하는 거죠. 예시로 peerDependencies를 명시해야할 호스트 패키지로 플러그인 패키지과 리액트 컴포넌트를 들 수
있는데 여기서는 리액트 컴포넌트를 예시로 들어보겠습니다.</p>
<p>리액트로 여러분이 재사용 가능한 컴포넌트를 하나 만들었는데 너무 잘 만들어서 npm에 올려서 다른 프로젝트에서도
사용하고 싶다고 합시다. 그런데 사용하는 리액트 기능이 특정 버전 이상에서만 지원되기에 그 버전을 명시해주어야
합니다.</p>
<p>dependencies에 명시해주는 건 어떨까요? dependencies에 명시해주면 리액트가 내부에 설치됩니다.
리액트는 여러 개의 인스턴스가 실행되면 에러가 발생되며
<a href="https://ko.reactjs.org/warnings/invalid-hook-call-warning.html#duplicate-react">제대로 동작하지 않기에</a> dependencies는 안됩니다.</p>
<p>devDependencies는요? devDependencies는 위와 같은 현상이 발생하지 않는다는 장점은 있지만 우리의 컴포넌트가
특정 버전 이상의 리액트에서만 작동한다는 것을 알려줄 수 없습니다. 그나마 버전만 일치한다면 작동은 되겠군요.</p>
<p>여기서 peerDependencies가 필요하게 됩니다. peerDependencies에 선언된 의존성 패키지들은 설치도 되지 않으며,
우리의 패키지는 <strong>다른 패키지와 동작하는데 그 패키지의 버전이 다음과 같을 때 제대로 동작한다</strong>
라는 것을 알려줄 수 있습니다.</p>
<p>peerDependencies를 테스트하기 위해 임시로 <code>npm init</code>을 하고 리액트 15.7.0 버전과 peerDependencies에서 리액트
16.8.0 버전을 요구하는 패키지를 한 번 깔아보았더니 아래와 같이 에러가 나며 설치가 실패합니다.</p>
<p><img src="/img/2022-02-11-about-npm/test-peerDependencies.jpg" alt="test-peerDependencies.jpg"></p>
<p>이와 같이 peerDependencies는 직접적으로 필요하지는 않은 패키지의 호환되는 버전을 명시해주고 싶을 때
유용하게 쓸 수 있습니다.</p>
<h2 id="5-package-lock.json">package-lock.json</h2>
<p><code>npm init</code>을 하면 <code>package.json</code>이 하나 생기죠. 그 뒤 의존성 패키지를 설치하면
<code>package-lock.json</code>이라는 커다란 파일 하나가 또 생기게 됩니다. 안을 들여다 보면 의존하는
패키지 이름과 버전이 적혀 있는 걸로 보아 의존성을 관리하기 위해 생기는 파일인 것 같기는 한데,
<code>package-lock.json</code> 파일도 git remote 리포지토리에 같이 올려야 한다고 들어보셨을 것입니다.
이 파일은 왜 생기고 왜 필요한 걸까요? <code>package.json</code>만으로는 충분하지 못한걸까요?</p>
<p><code>package.json</code>은 우리가 직접 참조하고 있는 패키지만 버전을 명시할 수 있습니다. 그 아래 패키지들의 버전은
정해줄 수 없죠. 하지만 <code>package-lock.json</code>은 그 아래의 패키지까지 모두 버전을 명시해 줄 수 있습니다.
이로 얻을 수 있는 이점은 다음과 같습니다.</p>
<ul>
<li>패키지의 버전이 모두 동일한 환경에서 작업을 이어갈 수 있다. 개발 폴더를 지우거나, 다른 컴퓨터에서 시작해도!</li>
<li>문제가 발생하면 전 환경으로 돌아가서 비교하기가 쉽다.</li>
<li>전에 설치한 패키지들에 대해서는 메타데이터 프로세싱을 스킵함으로써 npm이 최적화한다.</li>
</ul>
<p>...등등 여러 가지가 있습니다. 따라서 소스 리포지토리에도 업로드를 해 다른 컴퓨터에서도 그대로
개발을 이어나갈 수 있습니다.</p>
<blockquote>
<p><code>package-lock.json</code>은 소스 컨트롤 시스템에 업로드하는 것을 권장하나, npm에는 Publish 시
업로드하지 말아야 하며, 설령 업로드된다 해도 프로젝트 루트에 존재하는 <code>package-lock.json</code>을 제외한
나머지들은 무시됩니다. 해당 내용은 <a href="https://docs.npmjs.com/cli/v8/configuring-npm/package-lock-json#package-lockjson-vs-npm-shrinkwrapjson">링크</a>를 참조해 주세요.</p>
</blockquote>
<h1 id="6-2.-npm-Command">2. npm Command</h1>
<p><code>npm &#x3C;Command></code> 명령어로 npm에서 지원하는 명령을 실행할 수 있습니다.
<a href="https://docs.npmjs.com/cli/v8/commands">공식 링크</a>에서 명령어들을 확인할 수 있는데,
수많은 npm 명령 중 몇 가지만 짧게 소개 드리려 합니다.
<br><br></p>
<h2 id="7-npm-audit">npm audit</h2>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line line-number" line="1"><span class="token function">npm</span> audit <span class="token punctuation">[</span>fix <span class="token punctuation">[</span>--dry-run<span class="token punctuation">]</span><span class="token punctuation">]</span>
</span></code></pre>
<p>의존성 트리에서 패키지 매니저에 보고된 취약점을 찾아서 보고합니다. <code>fix</code> 명령을 뒤에 붙이면
의존성 버전을 준수하면서 자동 업데이트를 수행합니다. <code>fix</code>에 <code>--dry-run</code> 옵션을 추가하면
실제 업데이트를 수행하지 않고 어떻게 바뀔지 실험을 해볼 수 있습니다.
<br><br></p>
<h2 id="8-npm-ci">npm ci</h2>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line line-number" line="1"><span class="token function">npm</span> ci
</span></code></pre>
<p>패키지 의존성의 <strong>Clean Install</strong>을 수행합니다. <code>node_modules</code> 폴더가 이미 존재한다면
자동으로 지워진 다음 설치가 실행됩니다. 단, <code>npm ci</code>는 <code>package-lock.json</code> 파일이 있어야만
동작합니다.
<br><br></p>
<h2 id="9-npm-completion">npm completion</h2>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line line-number" line="1"><span class="token function">npm</span> completion
</span></code></pre>
<p>npm 명령어의 쉘 자동완성을 지원하는 스크립트를 출력합니다. <code>npm completion >> ~/.zshrc</code>와
같이 수행하면 되곘군요.
<br><br></p>
<h2 id="10-npm-ls">npm ls</h2>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line line-number" line="1"><span class="token function">npm</span> <span class="token function">ls</span> <span class="token punctuation">[</span>-g<span class="token punctuation">]</span> <span class="token punctuation">[</span>--all<span class="token punctuation">]</span> <span class="token punctuation">[</span>--depth <span class="token operator">&#x3C;</span>number<span class="token operator">></span><span class="token punctuation">]</span>
</span></code></pre>
<p>설치된 패키지를 확인할 수 있으며, <code>--all</code> 플래그는 밑의 모든 패키지들까지, <code>--depth</code> 플래그는
명시한 깊이까지 확인할 수 있습니다.
<br><br></p>
<h2 id="11-npm-outdated">npm outdated</h2>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line line-number" line="1"><span class="token function">npm</span> outdated <span class="token punctuation">[</span>-g<span class="token punctuation">]</span>
</span></code></pre>
<p>사용 가능한 업데이트가 있는 패키지를 출력해줍니다. 현재 버전과, 버전 명세를 지키면서 업데이트
가능한 버전, 그리고 최신 버전이 출력됩니다.
<br><br></p>
<h2 id="12-npm-uninstall">npm uninstall</h2>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line line-number" line="1"><span class="token function">npm</span> uninstall <span class="token punctuation">[</span>-g<span class="token punctuation">]</span> <span class="token punctuation">[</span>--no-save<span class="token punctuation">]</span>
</span></code></pre>
<p>해당 패키지와 패키지의 의존성을 지웁니다. 기본적으로 <code>package.json</code>과 <code>package-lock.json</code>도
업데이트해주며, 이를 원치 않을 시 <code>--no-save</code> 플래그를 붙여주면 됩니다.
<br><br></p>
<h2 id="13-npm-update">npm update</h2>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line line-number" line="1"><span class="token function">npm</span> update <span class="token punctuation">[</span>-g<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">&#x3C;</span>pkg<span class="token operator">></span><span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</span></code></pre>
<p>버전 명세를 지키면서 의존하고 있는 패키지들을 업데이트합니다. 특정 패키지 이름을 붙여줄 시
해당 패키지만 업데이트를 수행합니다.
<br><br></p>
<h2 id="14-npm-pack">npm pack</h2>
<pre class="language-bash"><code class="language-bash code-highlight"><span class="code-line line-number" line="1"><span class="token function">npm</span> pack <span class="token punctuation">[</span>--dry-run<span class="token punctuation">]</span> <span class="token punctuation">[</span>./<span class="token operator">&#x3C;</span>path<span class="token operator">></span><span class="token punctuation">]</span>
</span></code></pre>
<p>주어진 경로의 로컬 디렉토리를 로컬 tarball 파일 형식의 npm 패키지로 패키지합니다.
결과로 나온 tarball 파일은 npm에 업로드된 패키지와 동일하게 <code>npm i &#x3C;path></code>로 인스톨할 수 있는데,
npm deploy 하기 전 정상 작동이 되는지 테스트할 때 유용합니다.
위와 같이 path를 지정해주면 특정 폴더를 타겟팅해 패키지할 수도 있습니다. <code>./dist</code> 폴더를 예를 들 수 있죠.</p>
<blockquote>
<p>현재 npm v8, v9 버전에서는 path를 지정해 줄 시<code>./</code>나 <code>/</code>로 시작해야 합니다.
그렇지 않으면 현재 위치한 폴더를 빌드하고 tarball 파일 이름이 해당 path로 네이밍될 뿐입니다.
자세한 내용은 <a href="https://docs.npmjs.com/cli/v8/using-npm/package-spec">&#x3C;package-spec></a>을 참조하세요.</p>
</blockquote>
<h1 id="15-3.-NodeJS에서-import-쓰기">3. NodeJS에서 <code>import</code> 쓰기</h1>
<p>예전 자바스크립트를 많이 쓰지 않았을 때에는 다른 파일에서 다른 객체 등을 가져와서
쓸 수 있는 공식적인 방법이 존재하지 않았습니다. 이 때문에 임포트 모듈 신택스가 파편화되었는데,
NodeJS에서는 <code>require</code>로 잘 알려져 있는 <code>commonJS</code> 방식을 택했죠.
그 뒤 공식적으로는 <code>ES Module</code>이라 불리는 <code>import</code> 구문이 등장하게 되었습니다.</p>
<p>어디서는 require, 또 어디서는 import를 쓰기에 헷갈리기도 하고 또 브라우저나 NodeJS에서
쓰던 스크립트 파일을 가져다가 다른 환경에서 쓰려면 임포트 구문을 일일히 바꾸어야 하는
번잡함이 있었는데 <code>package.json</code>에 속성 하나만 추가해주면 이런 수고를 덜 수 있습니다.</p>
<p><code>package.json</code>에서 아래 속성을 추가해 주면 NodeJS에서도 import 구문을 사용할 수 있습니다.</p>
<pre class="language-js"><code class="language-js code-highlight"><span class="code-line line-number" line="1">  <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">"module"</span>
</span></code></pre>
<p>이 외에 또 다른 방식으로는 자바스크립트의 확장자를 <code>.mjs</code>로 수정하는 방법도 존재합니다.<br>
<a href="https://nodejs.org/docs/latest-v16.x/api/esm.html">참조</a></p>
<h1 id="16-4.-npm-vs.-yarn">4. npm vs. yarn</h1>
<p>NodeJS 패키지 매니저는 npm 말고도 <a href="https://yarnpkg.com/">yarn</a>이라는 매니저도 존재합니다.
yarn과 npm을 비교한 글은 인터넷 상에서 많이 찾아 보실 수 있습니다. 보통 yarn이 성능이 더 낫고
보안성이 높다고 합니다. 둘을 선택하는데 가장 큰 영향을 줄 요소는 내가 필요한 패키지를 받을 수
있는가가 아닐까 싶습니다.</p>
<h1 id="17-5.-참조">5. 참조</h1>
<blockquote>
<p><a href="https://docs.npmjs.com/about-semantic-versioning">https://docs.npmjs.com/about-semantic-versioning</a></p>
<p><a href="https://nodejs.dev/learn/semantic-versioning-using-npm">https://nodejs.dev/learn/semantic-versioning-using-npm</a></p>
<p><a href="https://semver.npmjs.com/">https://semver.npmjs.com/</a></p>
<p><a href="https://nodejs.org/es/blog/npm/peer-dependencies/">https://nodejs.org/es/blog/npm/peer-dependencies/</a></p>
<p><a href="https://nodejs.org/docs/latest-v16.x/api/esm.html">https://nodejs.org/docs/latest-v16.x/api/esm.html</a></p>
</blockquote><!-- HTML_TAG_END --></main></div></div> <footer class="p-2 py-5 text-sm flex gap-1 flex-col md:flex-row items-center justify-between border-t border-gray-300 bg-gray-50 dark:border-gray-700 dark:bg-[#2c3039]"><div>©️ 2021~2023 dlguswo333; All rights reserved.</div> <div class="flex items-center"><a class="inline-flex items-center" href="https://github.com/dlguswo333/dlguswo333.github.io"><img class="inline h-4 w-4 mr-1" src="/github-mark.svg" alt="github-mark"></a>
    Built with Sveltekit.</div></footer>  
			
			<script>
				{
					__sveltekit_1yoqa71 = {
						base: new URL("../..", location).pathname.slice(0, -1),
						env: {}
					};

					const element = document.currentScript.parentElement;

					const data = [null,{"type":"data","data":{html:"\u003Cp align=\"center\">\n  \u003Cimg src=\"/img/2022-02-11-about-npm/npm-logo.svg\">\n\u003C/p>\n\u003Cp>Node Package Manager, npm은 NodeJS 패키지 매니저로서 패키지 설치, 의존성 관리의 역할을 수행합니다.\u003C/p>\n\u003C!--more-->\n\u003Cp>JS 개발자로서 매일 같이 유용하게 쓰고 있음에도 불구하고 npm에 대해 마음을 다잡고 공부해 본 적이 없어서\n이 포스트를 쓰게 되었습니다. npm에서 자주 쓰이지만 따로 공부하지 않으면 제대로 알기 힘든 기능을\n중심으로 훑어가도록 하겠습니다.\u003C/p>\n\u003Ch1 id=\"1-1.-의존성-관리\">1. 의존성 관리\u003C/h1>\n\u003Cp>npm에서는 패키지의 이름, 작성자, 설명과 의존성 관리 등을 \u003Ccode>package.json\u003C/code>을 통해 관리하고 있습니다.\n\u003Ccode>npm init\u003C/code>을 하면 프로젝트 루트 폴더에 생기는 바로 그 파일인데, 여기에 패키지에 대한 정보를 json 형태로\n저장하게 됩니다. \u003Ccode>package.json\u003C/code>은 사람 뿐만 아니라 npm에서도 패키지 정보를 얻기 위해 활용하기 때문에\n지우면 안됩니다.\u003C/p>\n\u003Cblockquote>\n\u003Cp>참고로 \u003Ccode>npm ls\u003C/code>를 실행하면 의존성 패키지 목록을 훑어볼 수 있습니다. 여기에 \u003Ccode>--depth &#x3C;Number>\u003C/code> 파라미터를\n넘겨주면 의존 패키지가 또 의존하는 패키지를 해당 깊이만큼 트리 형태로 볼 수 있습니다. 여기에 \u003Ccode>-g\u003C/code> 또는\n\u003Ccode>--global\u003C/code> 플래그를 넘겨주면 글로벌 스코프로 설치된 패키지의 의존성 트리를 볼 수 있습니다.\u003C/p>\n\u003C/blockquote>\n\u003Ch2 id=\"2-버전-명세\">버전 명세\u003C/h2>\n\u003Cp>NodeJS 패키지들은 \u003Ccode>x.y.z\u003C/code>와 같이 세 개의 숫자로 구성된 버전 형식을 사용하는데, 이를\n\u003Cem>Semantic Versioning\u003C/em>이라 합니다. 년-월-일과 같이 세 숫자는 메이저-마이너-패치의 의미를 가지고 있습니다.\n왼쪽으로 갈수록 패키지가 많이 다르다는 뜻이죠. 버그 픽스를 반영했으면 \u003Ccode>z\u003C/code>를 바꾸고, 기능이 추가되면서\n전 버전과 호환되면 \u003Ccode>y\u003C/code>를, 전 버전과 호환이 안 되거나 그 만큼의 기능이 바뀌었으면 \u003Ccode>x\u003C/code>를 바꿔주는 방법으로\n버전을 정하면 됩니다.\u003C/p>\n\u003Cp>물론 이를 반드시 지키지 않아도 되고 실제로 지키지 않아도 npm에 패키지 업로드는 잘 됩니다만, 이를 지켜주는게\n좋습니다. npm에서 의존성 관리를 할 때 의존하고 있는 패키지 버전을 위 규칙을 기반으로 관리하기 때문입니다.\u003C/p>\n\u003Cp>패키지를 설치하고 \u003Ccode>package.json\u003C/code>에 들어가면 dependencies 또는 devdependencies에 의존 패키지 이름과\n함께 버전이 적혀 있는데 버전만 적혀있는 것이 아니라 \u003Ccode>^x.y.z\u003C/code>, \u003Ccode>>=x.y.z\u003C/code>와 같이 특수문자를 포함해서\n적혀있는 것을 보셨을 겁니다. 사용할 수 있는 특수문자와 그 의미는 아래와 같습니다.\u003C/p>\n\u003Cp>\u003Cstrong>^\u003C/strong>\u003Cbr>\n\u003Ccode>^x.y.z\u003C/code>와 같이 쓰며 가장 왼쪽의 0이 아닌 값을 바꾸지 않는 선에서 그 이상의 버전을 사용 가능.\n예를 들어 \u003Ccode>^1.0.0\u003C/code>일 때 \u003Ccode>1.0.1\u003C/code>, \u003Ccode>1.1.0\u003C/code>으로 업데이트는 가능하지만 \u003Ccode>2.0.0\u003C/code>으로는 업데이트 하지 않습니다.\n또 \u003Ccode>^0.3.0\u003C/code>이면 \u003Ccode>0.3.1\u003C/code>과 \u003Ccode>0.3.2\u003C/code>는 가능하지만 \u003Ccode>0.4.0\u003C/code>은 불가능합니다.\u003C/p>\n\u003Cp>\u003Cstrong>~\u003C/strong>\u003Cbr>\n\u003Ccode>~x.y.z\u003C/code>와 같이 쓰며 \u003Ccode>z\u003C/code> 버전만 바꾸는 선에서 그 이상의 버전을 사용 가능. 예를 들어 \u003Ccode>~1.0.0\u003C/code>일 때\n\u003Ccode>1.0.1\u003C/code>은 가능하지만 \u003Ccode>1.1.0\u003C/code>은 불가능합니다.\u003C/p>\n\u003Cp>\u003Cstrong>>\u003C/strong>\u003Cbr>\n\u003Ccode>>x.y.z\u003C/code>와 같이 쓰며 \u003Ccode>x.y.z\u003C/code>보다 높은 버전을 명시하기 위해 사용합니다.\u003C/p>\n\u003Cp>\u003Cstrong>>=\u003C/strong>\u003Cbr>\n\u003Ccode>>=x.y.z\u003C/code>와 같이 쓰며 \u003Ccode>x.y.z\u003C/code> 이상의 버전을 명시하기 위해 사용합니다.\u003C/p>\n\u003Cp>\u003Cstrong>&#x3C;\u003C/strong>\u003Cbr>\n\u003Ccode>&#x3C;x.y.z\u003C/code>와 같이 쓰며 \u003Ccode>x.y.z\u003C/code>보다 낮은 버전을 명시하기 위해 사용합니다.\u003C/p>\n\u003Cp>\u003Cstrong>&#x3C;=\u003C/strong>\u003Cbr>\n\u003Ccode>&#x3C;=x.y.z\u003C/code>와 같이 쓰며 \u003Ccode>x.y.z\u003C/code> 이하의 버전을 명시하기 위해 사용합니다.\u003C/p>\n\u003Cp>\u003Cstrong>=\u003C/strong>\u003Cbr>\n\u003Ccode>=x.y.z\u003C/code>와 같이 쓰며 \u003Ccode>x.y.z\u003C/code> 버전 만을 명시하기 위해 사용합니다. \u003Ccode>x.y.z\u003C/code>와 같은 효과를 가집니다.\u003C/p>\n\u003Cp>\u003Cstrong>-\u003C/strong>\u003Cbr>\n\u003Ccode>a.b.c - x.y.z\u003C/code>와 같이 쓰며 범위를 지정할 때 사용합니다. 이 때 범위는 양쪽 inclusive 입니다.\u003C/p>\n\u003Cp>\u003Cstrong>||\u003C/strong>\u003Cbr>\n\u003Ccode>&#x3C;...> || &#x3C;...>\u003C/code>와 같이 쓰며 두 명세를 조합할 때 (OR) 쓸 때 사용합니다. 예를 들어 \u003Ccode>0.1.0 || ^1.0.0\u003C/code>은\n\u003Ccode>0.1.0\u003C/code> 버전과 \u003Ccode>1.y.z\u003C/code> 버전을 명시할 수 있습니다.\u003C/p>\n\u003Cblockquote>\n\u003Cp>직접 시험해보고 싶으시다면 원하시는 특정 패키지에 대해 Semantic Versioning을 테스트해볼 수 있는\nnpm 공식 사이트 (\u003Ca href=\"https://semver.npmjs.com/\">링크\u003C/a>)가 존재합니다.\u003C/p>\n\u003C/blockquote>\n\u003Ch2 id=\"3-dependencies-vs.-devDependencies\">dependencies vs. devDependencies\u003C/h2>\n\u003Cp>npm 패키지에서 의존성들은 dependencies와 devDependencies로 관리합니다. 패키지 실행 시 필요한 (런타임)\n의존성들은 dependencies로, 그 외 개발에 필요한 패키지들은 devDependencies로 가는 식으로 나눠주죠.\u003C/p>\n\u003Cblockquote>\n\u003Cp>일일이 \u003Ccode>package.json\u003C/code>에 들어가 분리할 필요 없이\n\u003Ccode>npm i &#x3C;Package Name>\u003C/code>에 \u003Ccode>--save\u003C/code> (또는 \u003Ccode>-S\u003C/code>) 플래그를 붙이면 dependencies로,\n\u003Ccode>npm i &#x3C;Package Name>\u003C/code>에 \u003Ccode>--save-dev\u003C/code> (또는 \u003Ccode>-D\u003C/code>) 플래그를 붙이면 devDependencies로 알아서\nnpm이 분리해줍니다.\u003C/p>\n\u003C/blockquote>\n\u003Cp>예를 들어 eslint로 코드 컨벤션을 관리하며 express.JS로 백엔드 서버를 제작했다고 합시다.\neslint는 런타임에는 전혀 필요가 없고 서버를 돌릴 때 코드 컨벤션은 맞춰줄 필요가 없으니 devDependencies로,\nexpress.JS는 서버 런타임 동작 시 필요하니 dependencies로 지정하는 것이 적합하겠죠.\u003C/p>\n\u003Cp>그런데 \u003Ccode>npm install\u003C/code> (또는 \u003Ccode>npm i\u003C/code>) 명령어를 통해 의존성 패키지를 설치 시 dependencies 뿐만 아니라\ndevDependencies도 함께 설치됨을 알 수 있습니다. 어차피 둘 다 한꺼번에 설치되는데 왜 굳이 분리하는 걸까요?\u003C/p>\n\u003Cp>이는 우리가 제작한 패키지가 다른 패키지에 의해 참조될 때를 위한 것입니다. 우리가 git을 통해 패키지를 내려 받고\n제작하는 것은 해당 패키지를 직접 뜯어 고치는 작업입니다. 이미 우리가 해당 패키지를 개발한다는 의미를 지니고 있기에\n인스톨 명령 시 두 의존성을 다 설치하는 것이죠.\u003C/p>\n\u003Cp>하지만 다른 패키지가 우리 패키지에 의존할 시에는 상황이 다릅니다. 우리 패키지가 필요한 것이지, 직접 뜯어 고치고\n싶지는 않을테죠. 다시 위의 express.JS 백엔드 서버를 예를 들어봅시다. 누군가가 우리의 백엔드 서버를 필요로 해서\n의존성으로 설치할 시 express.JS는 dependencies에 명시되어 있기에 자동적으로 설치되겠지만 eslint는 설치되지\n않을 것입니다. devDependencies에 명시되어 있으니까요.\u003C/p>\n\u003Ch2 id=\"4-peerDependencies\">peerDependencies\u003C/h2>\n\u003Cp>peerDependencies란 \u003Cstrong>이 패키지가 이러한 의존 패키지들을 직접적으로 사용하지는 않지만 명시한 버전만 사용 가능하다\u003C/strong>\n라는 것을 표현하고 싶을 때 사용합니다. 즉 다시 말해 런타임 시 필요하지는 않지만 호환되는 버전을 나타내고 싶을 때\n사용하는 거죠. 예시로 peerDependencies를 명시해야할 호스트 패키지로 플러그인 패키지과 리액트 컴포넌트를 들 수\n있는데 여기서는 리액트 컴포넌트를 예시로 들어보겠습니다.\u003C/p>\n\u003Cp>리액트로 여러분이 재사용 가능한 컴포넌트를 하나 만들었는데 너무 잘 만들어서 npm에 올려서 다른 프로젝트에서도\n사용하고 싶다고 합시다. 그런데 사용하는 리액트 기능이 특정 버전 이상에서만 지원되기에 그 버전을 명시해주어야\n합니다.\u003C/p>\n\u003Cp>dependencies에 명시해주는 건 어떨까요? dependencies에 명시해주면 리액트가 내부에 설치됩니다.\n리액트는 여러 개의 인스턴스가 실행되면 에러가 발생되며\n\u003Ca href=\"https://ko.reactjs.org/warnings/invalid-hook-call-warning.html#duplicate-react\">제대로 동작하지 않기에\u003C/a> dependencies는 안됩니다.\u003C/p>\n\u003Cp>devDependencies는요? devDependencies는 위와 같은 현상이 발생하지 않는다는 장점은 있지만 우리의 컴포넌트가\n특정 버전 이상의 리액트에서만 작동한다는 것을 알려줄 수 없습니다. 그나마 버전만 일치한다면 작동은 되겠군요.\u003C/p>\n\u003Cp>여기서 peerDependencies가 필요하게 됩니다. peerDependencies에 선언된 의존성 패키지들은 설치도 되지 않으며,\n우리의 패키지는 \u003Cstrong>다른 패키지와 동작하는데 그 패키지의 버전이 다음과 같을 때 제대로 동작한다\u003C/strong>\n라는 것을 알려줄 수 있습니다.\u003C/p>\n\u003Cp>peerDependencies를 테스트하기 위해 임시로 \u003Ccode>npm init\u003C/code>을 하고 리액트 15.7.0 버전과 peerDependencies에서 리액트\n16.8.0 버전을 요구하는 패키지를 한 번 깔아보았더니 아래와 같이 에러가 나며 설치가 실패합니다.\u003C/p>\n\u003Cp>\u003Cimg src=\"/img/2022-02-11-about-npm/test-peerDependencies.jpg\" alt=\"test-peerDependencies.jpg\">\u003C/p>\n\u003Cp>이와 같이 peerDependencies는 직접적으로 필요하지는 않은 패키지의 호환되는 버전을 명시해주고 싶을 때\n유용하게 쓸 수 있습니다.\u003C/p>\n\u003Ch2 id=\"5-package-lock.json\">package-lock.json\u003C/h2>\n\u003Cp>\u003Ccode>npm init\u003C/code>을 하면 \u003Ccode>package.json\u003C/code>이 하나 생기죠. 그 뒤 의존성 패키지를 설치하면\n\u003Ccode>package-lock.json\u003C/code>이라는 커다란 파일 하나가 또 생기게 됩니다. 안을 들여다 보면 의존하는\n패키지 이름과 버전이 적혀 있는 걸로 보아 의존성을 관리하기 위해 생기는 파일인 것 같기는 한데,\n\u003Ccode>package-lock.json\u003C/code> 파일도 git remote 리포지토리에 같이 올려야 한다고 들어보셨을 것입니다.\n이 파일은 왜 생기고 왜 필요한 걸까요? \u003Ccode>package.json\u003C/code>만으로는 충분하지 못한걸까요?\u003C/p>\n\u003Cp>\u003Ccode>package.json\u003C/code>은 우리가 직접 참조하고 있는 패키지만 버전을 명시할 수 있습니다. 그 아래 패키지들의 버전은\n정해줄 수 없죠. 하지만 \u003Ccode>package-lock.json\u003C/code>은 그 아래의 패키지까지 모두 버전을 명시해 줄 수 있습니다.\n이로 얻을 수 있는 이점은 다음과 같습니다.\u003C/p>\n\u003Cul>\n\u003Cli>패키지의 버전이 모두 동일한 환경에서 작업을 이어갈 수 있다. 개발 폴더를 지우거나, 다른 컴퓨터에서 시작해도!\u003C/li>\n\u003Cli>문제가 발생하면 전 환경으로 돌아가서 비교하기가 쉽다.\u003C/li>\n\u003Cli>전에 설치한 패키지들에 대해서는 메타데이터 프로세싱을 스킵함으로써 npm이 최적화한다.\u003C/li>\n\u003C/ul>\n\u003Cp>...등등 여러 가지가 있습니다. 따라서 소스 리포지토리에도 업로드를 해 다른 컴퓨터에서도 그대로\n개발을 이어나갈 수 있습니다.\u003C/p>\n\u003Cblockquote>\n\u003Cp>\u003Ccode>package-lock.json\u003C/code>은 소스 컨트롤 시스템에 업로드하는 것을 권장하나, npm에는 Publish 시\n업로드하지 말아야 하며, 설령 업로드된다 해도 프로젝트 루트에 존재하는 \u003Ccode>package-lock.json\u003C/code>을 제외한\n나머지들은 무시됩니다. 해당 내용은 \u003Ca href=\"https://docs.npmjs.com/cli/v8/configuring-npm/package-lock-json#package-lockjson-vs-npm-shrinkwrapjson\">링크\u003C/a>를 참조해 주세요.\u003C/p>\n\u003C/blockquote>\n\u003Ch1 id=\"6-2.-npm-Command\">2. npm Command\u003C/h1>\n\u003Cp>\u003Ccode>npm &#x3C;Command>\u003C/code> 명령어로 npm에서 지원하는 명령을 실행할 수 있습니다.\n\u003Ca href=\"https://docs.npmjs.com/cli/v8/commands\">공식 링크\u003C/a>에서 명령어들을 확인할 수 있는데,\n수많은 npm 명령 중 몇 가지만 짧게 소개 드리려 합니다.\n\u003Cbr>\u003Cbr>\u003C/p>\n\u003Ch2 id=\"7-npm-audit\">npm audit\u003C/h2>\n\u003Cpre class=\"language-bash\">\u003Ccode class=\"language-bash code-highlight\">\u003Cspan class=\"code-line line-number\" line=\"1\">\u003Cspan class=\"token function\">npm\u003C/span> audit \u003Cspan class=\"token punctuation\">[\u003C/span>fix \u003Cspan class=\"token punctuation\">[\u003C/span>--dry-run\u003Cspan class=\"token punctuation\">]\u003C/span>\u003Cspan class=\"token punctuation\">]\u003C/span>\n\u003C/span>\u003C/code>\u003C/pre>\n\u003Cp>의존성 트리에서 패키지 매니저에 보고된 취약점을 찾아서 보고합니다. \u003Ccode>fix\u003C/code> 명령을 뒤에 붙이면\n의존성 버전을 준수하면서 자동 업데이트를 수행합니다. \u003Ccode>fix\u003C/code>에 \u003Ccode>--dry-run\u003C/code> 옵션을 추가하면\n실제 업데이트를 수행하지 않고 어떻게 바뀔지 실험을 해볼 수 있습니다.\n\u003Cbr>\u003Cbr>\u003C/p>\n\u003Ch2 id=\"8-npm-ci\">npm ci\u003C/h2>\n\u003Cpre class=\"language-bash\">\u003Ccode class=\"language-bash code-highlight\">\u003Cspan class=\"code-line line-number\" line=\"1\">\u003Cspan class=\"token function\">npm\u003C/span> ci\n\u003C/span>\u003C/code>\u003C/pre>\n\u003Cp>패키지 의존성의 \u003Cstrong>Clean Install\u003C/strong>을 수행합니다. \u003Ccode>node_modules\u003C/code> 폴더가 이미 존재한다면\n자동으로 지워진 다음 설치가 실행됩니다. 단, \u003Ccode>npm ci\u003C/code>는 \u003Ccode>package-lock.json\u003C/code> 파일이 있어야만\n동작합니다.\n\u003Cbr>\u003Cbr>\u003C/p>\n\u003Ch2 id=\"9-npm-completion\">npm completion\u003C/h2>\n\u003Cpre class=\"language-bash\">\u003Ccode class=\"language-bash code-highlight\">\u003Cspan class=\"code-line line-number\" line=\"1\">\u003Cspan class=\"token function\">npm\u003C/span> completion\n\u003C/span>\u003C/code>\u003C/pre>\n\u003Cp>npm 명령어의 쉘 자동완성을 지원하는 스크립트를 출력합니다. \u003Ccode>npm completion >> ~/.zshrc\u003C/code>와\n같이 수행하면 되곘군요.\n\u003Cbr>\u003Cbr>\u003C/p>\n\u003Ch2 id=\"10-npm-ls\">npm ls\u003C/h2>\n\u003Cpre class=\"language-bash\">\u003Ccode class=\"language-bash code-highlight\">\u003Cspan class=\"code-line line-number\" line=\"1\">\u003Cspan class=\"token function\">npm\u003C/span> \u003Cspan class=\"token function\">ls\u003C/span> \u003Cspan class=\"token punctuation\">[\u003C/span>-g\u003Cspan class=\"token punctuation\">]\u003C/span> \u003Cspan class=\"token punctuation\">[\u003C/span>--all\u003Cspan class=\"token punctuation\">]\u003C/span> \u003Cspan class=\"token punctuation\">[\u003C/span>--depth \u003Cspan class=\"token operator\">&#x3C;\u003C/span>number\u003Cspan class=\"token operator\">>\u003C/span>\u003Cspan class=\"token punctuation\">]\u003C/span>\n\u003C/span>\u003C/code>\u003C/pre>\n\u003Cp>설치된 패키지를 확인할 수 있으며, \u003Ccode>--all\u003C/code> 플래그는 밑의 모든 패키지들까지, \u003Ccode>--depth\u003C/code> 플래그는\n명시한 깊이까지 확인할 수 있습니다.\n\u003Cbr>\u003Cbr>\u003C/p>\n\u003Ch2 id=\"11-npm-outdated\">npm outdated\u003C/h2>\n\u003Cpre class=\"language-bash\">\u003Ccode class=\"language-bash code-highlight\">\u003Cspan class=\"code-line line-number\" line=\"1\">\u003Cspan class=\"token function\">npm\u003C/span> outdated \u003Cspan class=\"token punctuation\">[\u003C/span>-g\u003Cspan class=\"token punctuation\">]\u003C/span>\n\u003C/span>\u003C/code>\u003C/pre>\n\u003Cp>사용 가능한 업데이트가 있는 패키지를 출력해줍니다. 현재 버전과, 버전 명세를 지키면서 업데이트\n가능한 버전, 그리고 최신 버전이 출력됩니다.\n\u003Cbr>\u003Cbr>\u003C/p>\n\u003Ch2 id=\"12-npm-uninstall\">npm uninstall\u003C/h2>\n\u003Cpre class=\"language-bash\">\u003Ccode class=\"language-bash code-highlight\">\u003Cspan class=\"code-line line-number\" line=\"1\">\u003Cspan class=\"token function\">npm\u003C/span> uninstall \u003Cspan class=\"token punctuation\">[\u003C/span>-g\u003Cspan class=\"token punctuation\">]\u003C/span> \u003Cspan class=\"token punctuation\">[\u003C/span>--no-save\u003Cspan class=\"token punctuation\">]\u003C/span>\n\u003C/span>\u003C/code>\u003C/pre>\n\u003Cp>해당 패키지와 패키지의 의존성을 지웁니다. 기본적으로 \u003Ccode>package.json\u003C/code>과 \u003Ccode>package-lock.json\u003C/code>도\n업데이트해주며, 이를 원치 않을 시 \u003Ccode>--no-save\u003C/code> 플래그를 붙여주면 됩니다.\n\u003Cbr>\u003Cbr>\u003C/p>\n\u003Ch2 id=\"13-npm-update\">npm update\u003C/h2>\n\u003Cpre class=\"language-bash\">\u003Ccode class=\"language-bash code-highlight\">\u003Cspan class=\"code-line line-number\" line=\"1\">\u003Cspan class=\"token function\">npm\u003C/span> update \u003Cspan class=\"token punctuation\">[\u003C/span>-g\u003Cspan class=\"token punctuation\">]\u003C/span> \u003Cspan class=\"token punctuation\">[\u003C/span>\u003Cspan class=\"token operator\">&#x3C;\u003C/span>pkg\u003Cspan class=\"token operator\">>\u003C/span>\u003Cspan class=\"token punctuation\">..\u003C/span>.\u003Cspan class=\"token punctuation\">]\u003C/span>\n\u003C/span>\u003C/code>\u003C/pre>\n\u003Cp>버전 명세를 지키면서 의존하고 있는 패키지들을 업데이트합니다. 특정 패키지 이름을 붙여줄 시\n해당 패키지만 업데이트를 수행합니다.\n\u003Cbr>\u003Cbr>\u003C/p>\n\u003Ch2 id=\"14-npm-pack\">npm pack\u003C/h2>\n\u003Cpre class=\"language-bash\">\u003Ccode class=\"language-bash code-highlight\">\u003Cspan class=\"code-line line-number\" line=\"1\">\u003Cspan class=\"token function\">npm\u003C/span> pack \u003Cspan class=\"token punctuation\">[\u003C/span>--dry-run\u003Cspan class=\"token punctuation\">]\u003C/span> \u003Cspan class=\"token punctuation\">[\u003C/span>./\u003Cspan class=\"token operator\">&#x3C;\u003C/span>path\u003Cspan class=\"token operator\">>\u003C/span>\u003Cspan class=\"token punctuation\">]\u003C/span>\n\u003C/span>\u003C/code>\u003C/pre>\n\u003Cp>주어진 경로의 로컬 디렉토리를 로컬 tarball 파일 형식의 npm 패키지로 패키지합니다.\n결과로 나온 tarball 파일은 npm에 업로드된 패키지와 동일하게 \u003Ccode>npm i &#x3C;path>\u003C/code>로 인스톨할 수 있는데,\nnpm deploy 하기 전 정상 작동이 되는지 테스트할 때 유용합니다.\n위와 같이 path를 지정해주면 특정 폴더를 타겟팅해 패키지할 수도 있습니다. \u003Ccode>./dist\u003C/code> 폴더를 예를 들 수 있죠.\u003C/p>\n\u003Cblockquote>\n\u003Cp>현재 npm v8, v9 버전에서는 path를 지정해 줄 시\u003Ccode>./\u003C/code>나 \u003Ccode>/\u003C/code>로 시작해야 합니다.\n그렇지 않으면 현재 위치한 폴더를 빌드하고 tarball 파일 이름이 해당 path로 네이밍될 뿐입니다.\n자세한 내용은 \u003Ca href=\"https://docs.npmjs.com/cli/v8/using-npm/package-spec\">&#x3C;package-spec>\u003C/a>을 참조하세요.\u003C/p>\n\u003C/blockquote>\n\u003Ch1 id=\"15-3.-NodeJS에서-import-쓰기\">3. NodeJS에서 \u003Ccode>import\u003C/code> 쓰기\u003C/h1>\n\u003Cp>예전 자바스크립트를 많이 쓰지 않았을 때에는 다른 파일에서 다른 객체 등을 가져와서\n쓸 수 있는 공식적인 방법이 존재하지 않았습니다. 이 때문에 임포트 모듈 신택스가 파편화되었는데,\nNodeJS에서는 \u003Ccode>require\u003C/code>로 잘 알려져 있는 \u003Ccode>commonJS\u003C/code> 방식을 택했죠.\n그 뒤 공식적으로는 \u003Ccode>ES Module\u003C/code>이라 불리는 \u003Ccode>import\u003C/code> 구문이 등장하게 되었습니다.\u003C/p>\n\u003Cp>어디서는 require, 또 어디서는 import를 쓰기에 헷갈리기도 하고 또 브라우저나 NodeJS에서\n쓰던 스크립트 파일을 가져다가 다른 환경에서 쓰려면 임포트 구문을 일일히 바꾸어야 하는\n번잡함이 있었는데 \u003Ccode>package.json\u003C/code>에 속성 하나만 추가해주면 이런 수고를 덜 수 있습니다.\u003C/p>\n\u003Cp>\u003Ccode>package.json\u003C/code>에서 아래 속성을 추가해 주면 NodeJS에서도 import 구문을 사용할 수 있습니다.\u003C/p>\n\u003Cpre class=\"language-js\">\u003Ccode class=\"language-js code-highlight\">\u003Cspan class=\"code-line line-number\" line=\"1\">  \u003Cspan class=\"token literal-property property\">type\u003C/span>\u003Cspan class=\"token operator\">:\u003C/span> \u003Cspan class=\"token string\">\"module\"\u003C/span>\n\u003C/span>\u003C/code>\u003C/pre>\n\u003Cp>이 외에 또 다른 방식으로는 자바스크립트의 확장자를 \u003Ccode>.mjs\u003C/code>로 수정하는 방법도 존재합니다.\u003Cbr>\n\u003Ca href=\"https://nodejs.org/docs/latest-v16.x/api/esm.html\">참조\u003C/a>\u003C/p>\n\u003Ch1 id=\"16-4.-npm-vs.-yarn\">4. npm vs. yarn\u003C/h1>\n\u003Cp>NodeJS 패키지 매니저는 npm 말고도 \u003Ca href=\"https://yarnpkg.com/\">yarn\u003C/a>이라는 매니저도 존재합니다.\nyarn과 npm을 비교한 글은 인터넷 상에서 많이 찾아 보실 수 있습니다. 보통 yarn이 성능이 더 낫고\n보안성이 높다고 합니다. 둘을 선택하는데 가장 큰 영향을 줄 요소는 내가 필요한 패키지를 받을 수\n있는가가 아닐까 싶습니다.\u003C/p>\n\u003Ch1 id=\"17-5.-참조\">5. 참조\u003C/h1>\n\u003Cblockquote>\n\u003Cp>\u003Ca href=\"https://docs.npmjs.com/about-semantic-versioning\">https://docs.npmjs.com/about-semantic-versioning\u003C/a>\u003C/p>\n\u003Cp>\u003Ca href=\"https://nodejs.dev/learn/semantic-versioning-using-npm\">https://nodejs.dev/learn/semantic-versioning-using-npm\u003C/a>\u003C/p>\n\u003Cp>\u003Ca href=\"https://semver.npmjs.com/\">https://semver.npmjs.com/\u003C/a>\u003C/p>\n\u003Cp>\u003Ca href=\"https://nodejs.org/es/blog/npm/peer-dependencies/\">https://nodejs.org/es/blog/npm/peer-dependencies/\u003C/a>\u003C/p>\n\u003Cp>\u003Ca href=\"https://nodejs.org/docs/latest-v16.x/api/esm.html\">https://nodejs.org/docs/latest-v16.x/api/esm.html\u003C/a>\u003C/p>\n\u003C/blockquote>",frontmatter:{layout:"post",toc:true,editedDate:"2022-12-19",title:"npm에 대하여",category:["Programming"],tags:["npm","javascript"],author:["이현재"]},date:"2022-02-11",lang:"ko",tocData:[{depth:1,id:"1-1.-의존성-관리",text:"1. 의존성 관리"},{depth:2,id:"2-버전-명세",text:"버전 명세"},{depth:2,id:"3-dependencies-vs.-devDependencies",text:"dependencies vs. devDependencies"},{depth:2,id:"4-peerDependencies",text:"peerDependencies"},{depth:2,id:"5-package-lock.json",text:"package-lock.json"},{depth:1,id:"6-2.-npm-Command",text:"2. npm Command"},{depth:2,id:"7-npm-audit",text:"npm audit"},{depth:2,id:"8-npm-ci",text:"npm ci"},{depth:2,id:"9-npm-completion",text:"npm completion"},{depth:2,id:"10-npm-ls",text:"npm ls"},{depth:2,id:"11-npm-outdated",text:"npm outdated"},{depth:2,id:"12-npm-uninstall",text:"npm uninstall"},{depth:2,id:"13-npm-update",text:"npm update"},{depth:2,id:"14-npm-pack",text:"npm pack"},{depth:1,id:"15-3.-NodeJS에서-import-쓰기",text:"3. NodeJS에서 import 쓰기"},{depth:1,id:"16-4.-npm-vs.-yarn",text:"4. npm vs. yarn"},{depth:1,id:"17-5.-참조",text:"5. 참조"}]},"uses":{"params":["year","slug"]}}];

					Promise.all([
						import("../../_app/immutable/entry/start.d2d44a37.js"),
						import("../../_app/immutable/entry/app.8cd8adc2.js")
					]).then(([kit, app]) => {
						kit.start(app, element, {
							node_ids: [0, 5],
							data,
							form: null,
							error: null
						});
					});
				}
			</script>
		</div>
	</body>
</html>
